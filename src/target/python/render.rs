use super::ast;
use crate::comment_fmt::surrounded_comment_block;
use anyhow::Result;
use std::collections::BTreeMap;
use std::io::Write;

struct IdState {
    id_table: Vec<(String, ast::Class)>,
    definition_names: BTreeMap<String, usize>,
}

const TYPE_WRAPPER_VALUE_HEREDOC: &'static str = "The underlying value being wrapped.";
const FROM_JSON_HEREDOC: &'static str = "Construct an instance of this class from JSON-like data.";
const TO_JSON_HEREDOC: &'static str = "Construct JSON-like data from an instance of this class.";

pub fn render(out: &mut dyn Write, ast_: ast::Ast) -> Result<()> {
    let id_state = IdState {
        id_table: ast_.classes.into_lookup_table().collect(),
        definition_names: ast_.definition_names,
    };

    writeln!(
        out,
        "# Code generated by jtd-codegen {}. DO NOT EDIT.",
        ast_.version
    )?;

    writeln!(out)?;

    for (module, identifiers) in ast_.imports {
        let identifiers: Vec<_> = identifiers.into_iter().collect();
        writeln!(out, "from {} import {}", module, identifiers.join(", "))?;
    }

    for (class_name, class) in &id_state.id_table {
        // Add a blank line between classes or between the first class and the
        // imports.
        writeln!(out)?;

        match class {
            ast::Class::TypeWrapper(type_wrapper) => {
                writeln!(out, "@dataclass")?;
                writeln!(out, "class {}:", class_name)?;

                if !type_wrapper.description.is_empty() {
                    writeln!(
                        out,
                        "{}",
                        surrounded_comment_block(
                            80,
                            "    \"\"\"",
                            "    \"\"\"",
                            "    ",
                            &type_wrapper.description
                        )
                    )?;
                }

                writeln!(
                    out,
                    "    value: '{}'",
                    render_type_ref(&id_state, &type_wrapper.type_),
                )?;

                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "    \"\"\"",
                        "    \"\"\"",
                        "    ",
                        TYPE_WRAPPER_VALUE_HEREDOC,
                    )
                )?;

                writeln!(out)?;
                writeln!(out, "    @classmethod")?;
                writeln!(out, "    def from_json(cls, data):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        FROM_JSON_HEREDOC
                    )
                )?;
                writeln!(
                    out,
                    "        return cls(_from_json({}, data))",
                    render_type_ref(&id_state, &type_wrapper.type_)
                )?;
                writeln!(out)?;
                writeln!(out, "    def to_json(self):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        TO_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        return _to_json(self.value)",)?;
            }

            ast::Class::Enum(enum_) => {
                writeln!(out, "class {}(Enum):", class_name)?;

                if !enum_.description.is_empty() {
                    writeln!(
                        out,
                        "{}",
                        surrounded_comment_block(
                            80,
                            "    \"\"\"",
                            "    \"\"\"",
                            "    ",
                            &enum_.description
                        )
                    )?;
                }

                for (member_name, member) in &enum_.members {
                    writeln!(out, "    {} = {}", member_name, member.value)?;

                    if !member.description.is_empty() {
                        writeln!(
                            out,
                            "{}",
                            surrounded_comment_block(
                                80,
                                "    \"\"\"",
                                "    \"\"\"",
                                "    ",
                                &member.description
                            )
                        )?;
                    }
                }

                writeln!(out)?;
                writeln!(out, "    @classmethod")?;
                writeln!(out, "    def from_json(cls, data):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        FROM_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        return cls(data)")?;
                writeln!(out)?;
                writeln!(out, "    def to_json(self):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        TO_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        return self.value")?;
            }

            ast::Class::Dataclass(dataclass) => {
                writeln!(out, "@dataclass")?;
                writeln!(out, "class {}:", class_name)?;

                if !dataclass.description.is_empty() {
                    writeln!(
                        out,
                        "{}",
                        surrounded_comment_block(
                            80,
                            "    \"\"\"",
                            "    \"\"\"",
                            "    ",
                            &dataclass.description
                        )
                    )?;
                }

                for (field_name, field) in &dataclass.fields {
                    writeln!(
                        out,
                        "    {}: '{}'",
                        field_name,
                        render_type_ref(&id_state, &field.type_)
                    )?;

                    if !field.description.is_empty() {
                        writeln!(
                            out,
                            "{}",
                            surrounded_comment_block(
                                80,
                                "    \"\"\"",
                                "    \"\"\"",
                                "    ",
                                &field.description
                            )
                        )?;
                    }
                }

                writeln!(out)?;
                writeln!(out, "    @classmethod")?;
                writeln!(out, "    def from_json(cls, data):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        FROM_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        return cls(")?;
                for (_, field) in &dataclass.fields {
                    writeln!(
                        out,
                        "            _from_json({}, data[{}]),",
                        render_type_ref(&id_state, &field.type_),
                        field.json_name,
                    )?;
                }
                writeln!(out, "        )")?;
                writeln!(out)?;
                writeln!(out, "    def to_json(self):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        TO_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        return {{")?;
                for (field_name, field) in &dataclass.fields {
                    writeln!(
                        out,
                        "            {}: _to_json(self.{}),",
                        field.json_name, field_name,
                    )?;
                }
                writeln!(out, "        }}")?;
            }

            ast::Class::Discriminator(discriminator) => {
                writeln!(out, "@dataclass")?;
                writeln!(out, "class {}:", class_name)?;

                if !discriminator.description.is_empty() {
                    writeln!(
                        out,
                        "{}",
                        surrounded_comment_block(
                            80,
                            "    \"\"\"",
                            "    \"\"\"",
                            "    ",
                            &discriminator.description
                        )
                    )?;
                }

                writeln!(out, "    {}: str", discriminator.discriminator_name)?;
                for (variant_name, variant) in &discriminator.variants {
                    writeln!(
                        out,
                        "    {}: 'Optional[{}]' = None",
                        variant_name,
                        render_type_ref(&id_state, &variant.type_),
                    )?;
                }

                writeln!(out)?;
                writeln!(out, "    @classmethod")?;
                writeln!(out, "    def from_json(cls, data):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        FROM_JSON_HEREDOC
                    )
                )?;
                writeln!(
                    out,
                    "        result = cls(data[{}])",
                    discriminator.discriminator_json_name
                )?;
                for (index, (variant_name, variant)) in discriminator.variants.iter().enumerate() {
                    let if_or_elif = if index == 0 { "if" } else { "elif" };
                    writeln!(
                        out,
                        "        {} data[{}] == {}:",
                        if_or_elif,
                        discriminator.discriminator_json_name,
                        variant.discriminator_value
                    )?;
                    writeln!(
                        out,
                        "            result.{} = {}.from_json(data)",
                        variant_name,
                        render_type_ref(&id_state, &variant.type_)
                    )?;
                }
                writeln!(out, "        return result")?;
                writeln!(out)?;
                writeln!(out, "    def to_json(self):")?;
                writeln!(
                    out,
                    "{}",
                    surrounded_comment_block(
                        80,
                        "        \"\"\"",
                        "        \"\"\"",
                        "        ",
                        TO_JSON_HEREDOC
                    )
                )?;
                writeln!(out, "        result = {{}}")?;
                for (index, (variant_name, variant)) in discriminator.variants.iter().enumerate() {
                    let if_or_elif = if index == 0 { "if" } else { "elif" };
                    writeln!(
                        out,
                        "        {} self.{} == {}:",
                        if_or_elif, discriminator.discriminator_name, variant.discriminator_value
                    )?;
                    writeln!(out, "            result = self.{}.to_json()", variant_name)?;
                }
                writeln!(
                    out,
                    "        result[{}] = self.{}",
                    discriminator.discriminator_json_name, discriminator.discriminator_name
                )?;
                writeln!(out, "        return result")?;
            }
        }
    }

    writeln!(out)?;
    out.write_all(include_bytes!("postamble.py"))?;

    Ok(())
}

fn render_type_ref(id_state: &IdState, type_ref: &ast::TypeRef) -> String {
    match type_ref {
        ast::TypeRef::Primitive(s) => s.clone(),
        ast::TypeRef::Identifier(id) => id_state.id_table[*id].0.clone(),
        ast::TypeRef::Optional(t) => format!("Optional[{}]", render_type_ref(id_state, t)),
        ast::TypeRef::ListOf(t) => format!("List[{}]", render_type_ref(id_state, t)),
        ast::TypeRef::DictOf(t) => format!("Dict[str, {}]", render_type_ref(id_state, t)),
        ast::TypeRef::Definition(d) => id_state.id_table[id_state.definition_names[d]].0.clone(),
    }
}
