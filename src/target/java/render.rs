use super::ast;
use crate::comment_fmt::surrounded_comment_block;
use anyhow::Result;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::Write;
use std::path::Path;

struct IdState {
    id_table: Vec<(String, ast::Type)>,
    definition_names: BTreeMap<String, usize>,
}

pub fn render(out_dir: &str, ast_: ast::Ast) -> Result<()> {
    let out_dir = Path::new(out_dir);

    let id_state = IdState {
        id_table: ast_.types.into_lookup_table().collect(),
        definition_names: ast_.definition_names,
    };

    // First, write out utility classes that are rendered unconditionally.
    let mut out = File::create(Path::join(out_dir, "UnsignedByte.java"))?;
    writeln!(
        out,
        "// Code generated by jtd-codegen {}. DO NOT EDIT.",
        ast_.version
    )?;
    writeln!(out, "package {};", ast_.package)?;
    writeln!(out)?;
    out.write_all(include_bytes!("UnsignedByte.java"))?;

    let mut out = File::create(Path::join(out_dir, "UnsignedShort.java"))?;
    writeln!(
        out,
        "// Code generated by jtd-codegen {}. DO NOT EDIT.",
        ast_.version
    )?;
    writeln!(out, "package {};", ast_.package)?;
    writeln!(out)?;
    out.write_all(include_bytes!("UnsignedShort.java"))?;

    let mut out = File::create(Path::join(out_dir, "UnsignedInteger.java"))?;
    writeln!(
        out,
        "// Code generated by jtd-codegen {}. DO NOT EDIT.",
        ast_.version
    )?;
    writeln!(out, "package {};", ast_.package)?;
    writeln!(out)?;
    out.write_all(include_bytes!("UnsignedInteger.java"))?;

    for (type_name, type_) in &id_state.id_table {
        let mut out = File::create(Path::join(
            Path::new(out_dir),
            format!("{}.java", type_name),
        ))?;

        writeln!(
            out,
            "// Code generated by jtd-codegen {}. DO NOT EDIT.",
            ast_.version
        )?;
        writeln!(out, "package {};", ast_.package)?;
        writeln!(out)?;

        match type_ {
            ast::Type::TypeWrapper(type_wrapper) => {
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonCreator;")?;
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonValue;")?;
                writeln!(out)?;

                writeln!(out, "public class {} {{", type_name)?;
                writeln!(out, "    @JsonValue")?;
                writeln!(
                    out,
                    "    public {} value;",
                    render_type_ref(&id_state, &type_wrapper.type_)
                )?;
                writeln!(out, "    @JsonCreator")?;
                writeln!(
                    out,
                    "    public {}({} value) {{",
                    type_name,
                    render_type_ref(&id_state, &type_wrapper.type_)
                )?;
                writeln!(out, "        this.value = value;")?;
                writeln!(out, "    }}")?;
                writeln!(out, "}}")?;
            }
            ast::Type::Enum(enum_) => {
                render_javadoc_indent0(&mut out, &enum_.description)?;
                writeln!(out, "public enum {} {{", type_name)?;
                for (index, (member_name, member)) in enum_.members.iter().enumerate() {
                    if index != 0 {
                        writeln!(out)?;
                    }

                    render_javadoc_indent1(&mut out, &member.description)?;
                    writeln!(
                        out,
                        "    @com.fasterxml.jackson.annotation.JsonProperty({})",
                        member.value
                    )?;
                    writeln!(out, "    {},", member_name)?;
                }
                writeln!(out, "}}")?;
            }
            ast::Type::Bean(bean) => {
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonProperty;")?;
                writeln!(out)?;
                writeln!(out, "import java.io.Serializable;")?;
                writeln!(out)?;

                render_javadoc_indent0(&mut out, &bean.description)?;

                writeln!(out, "public class {} implements Serializable {{", type_name)?;
                for (index, (field_name, field)) in bean.fields.iter().enumerate() {
                    if let ast::BeanField::Declaration(declaration) = field {
                        if index != 0 {
                            writeln!(out)?;
                        }

                        writeln!(out, "    @JsonProperty({:?})", declaration.json_name)?;
                        writeln!(
                            out,
                            "    private {} {};",
                            render_type_ref(&id_state, &declaration.type_),
                            field_name
                        )?;
                    }
                }

                writeln!(out)?;
                writeln!(out, "    public {}() {{", type_name)?;
                writeln!(out, "    }}")?;

                for (field_name, field) in &bean.fields {
                    if let ast::BeanField::Getter(getter) = field {
                        writeln!(out)?;
                        render_javadoc_indent1(&mut out, &getter.description)?;
                        writeln!(
                            out,
                            "    public {} {}() {{",
                            render_type_ref(&id_state, &getter.type_),
                            field_name,
                        )?;
                        writeln!(out, "        return this.{};", getter.ivar_name)?;
                        writeln!(out, "    }}")?;
                    }

                    if let ast::BeanField::Setter(setter) = field {
                        writeln!(out)?;
                        render_javadoc_indent1(&mut out, &setter.description)?;
                        writeln!(
                            out,
                            "    public void {}({} {}) {{",
                            field_name,
                            render_type_ref(&id_state, &setter.type_),
                            setter.ivar_name,
                        )?;
                        writeln!(
                            out,
                            "        this.{} = {};",
                            setter.ivar_name, setter.ivar_name
                        )?;
                        writeln!(out, "    }}")?;
                    }
                }

                writeln!(out, "}}")?;
            }
            ast::Type::Discriminator(discriminator) => {
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonProperty;")?;
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonSubTypes;")?;
                writeln!(out, "import com.fasterxml.jackson.annotation.JsonTypeInfo;")?;
                writeln!(out)?;
                writeln!(out, "import java.io.Serializable;")?;
                writeln!(out)?;

                render_javadoc_indent0(&mut out, &discriminator.description)?;
                writeln!(
                    out,
                    "@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = {})",
                    discriminator.discriminator_json_name
                )?;
                writeln!(out, "@JsonSubTypes({{")?;
                for (variant_name, variant) in &discriminator.variants {
                    writeln!(
                        out,
                        "    @JsonSubTypes.Type(name = {}, value = {}.{}.class),",
                        variant.discriminator_value, type_name, variant_name
                    )?;
                }
                writeln!(out, "}})")?;
                writeln!(out, "public abstract class {} {{", type_name)?;

                // Generate each of the variant beans as inner classes.
                for (index, (variant_name, variant)) in discriminator.variants.iter().enumerate() {
                    if index != 0 {
                        writeln!(out)?;
                    }

                    render_javadoc_indent1(&mut out, &variant.description)?;
                    writeln!(
                        out,
                        "    public static class {} extends {} implements Serializable {{",
                        variant_name, type_name
                    )?;

                    // Having to keep track of a count like this is a
                    // consequence of keeping declarations, getters, and setters
                    // in the same data structure.
                    //
                    // If the Ast for bean fields were re-organized,
                    // declaration_index would not need to exist.
                    let mut declaration_index = 0;
                    for (field_name, field) in &variant.fields {
                        if let ast::BeanField::Declaration(declaration) = field {
                            if declaration_index != 0 {
                                writeln!(out)?;
                            }

                            declaration_index += 1;

                            writeln!(out, "        @JsonProperty({:?})", declaration.json_name)?;
                            writeln!(
                                out,
                                "        private {} {};",
                                render_type_ref(&id_state, &declaration.type_),
                                field_name
                            )?;
                        }
                    }

                    writeln!(out)?;
                    writeln!(out, "        public {}() {{", variant_name)?;
                    writeln!(out, "        }}")?;

                    for (field_name, field) in &variant.fields {
                        if let ast::BeanField::Getter(getter) = field {
                            writeln!(out)?;
                            render_javadoc_indent2(&mut out, &getter.description)?;
                            writeln!(
                                out,
                                "        public {} {}() {{",
                                render_type_ref(&id_state, &getter.type_),
                                field_name,
                            )?;
                            writeln!(out, "            return this.{};", getter.ivar_name)?;
                            writeln!(out, "        }}")?;
                        }

                        if let ast::BeanField::Setter(setter) = field {
                            writeln!(out)?;
                            render_javadoc_indent2(&mut out, &setter.description)?;
                            writeln!(
                                out,
                                "        public void {}({} {}) {{",
                                field_name,
                                render_type_ref(&id_state, &setter.type_),
                                setter.ivar_name,
                            )?;
                            writeln!(
                                out,
                                "            this.{} = {};",
                                setter.ivar_name, setter.ivar_name
                            )?;
                            writeln!(out, "        }}")?;
                        }
                    }

                    writeln!(out, "    }}")?;
                }

                writeln!(out, "}}")?;
            }
        }
    }

    Ok(())
}

fn render_javadoc_indent0(out: &mut dyn Write, comment: &str) -> Result<()> {
    write!(
        out,
        "{}",
        surrounded_comment_block(80, "/**", " * ", " */", comment)
    )?;

    Ok(())
}

fn render_javadoc_indent1(out: &mut dyn Write, comment: &str) -> Result<()> {
    write!(
        out,
        "{}",
        surrounded_comment_block(80, "    /**", "     * ", "     */", comment)
    )?;

    Ok(())
}

fn render_javadoc_indent2(out: &mut dyn Write, comment: &str) -> Result<()> {
    write!(
        out,
        "{}",
        surrounded_comment_block(80, "        /**", "         * ", "         */", comment)
    )?;

    Ok(())
}

fn render_type_ref(id_state: &IdState, type_ref: &ast::TypeRef) -> String {
    match type_ref {
        ast::TypeRef::Primitive(s) => s.clone(),
        ast::TypeRef::Identifier(id) => id_state.id_table[*id].0.clone(),
        ast::TypeRef::ListOf(t) => format!("java.util.List<{}>", render_type_ref(id_state, t)),
        ast::TypeRef::DictOf(t) => {
            format!("java.util.Map<String, {}>", render_type_ref(id_state, t))
        }
        ast::TypeRef::Definition(d) => id_state.id_table[id_state.definition_names[d]].0.clone(),
    }
}
