use super::ast;
use crate::comment_fmt::surrounded_comment_block;
use anyhow::Result;
use std::collections::BTreeMap;
use std::io::Write;

struct IdState {
    id_table: Vec<(String, ast::Type)>,
    definition_names: BTreeMap<String, usize>,
}

pub fn render(out: &mut dyn Write, ast_: ast::Ast) -> Result<()> {
    let id_state = IdState {
        id_table: ast_.types.into_lookup_table().collect(),
        definition_names: ast_.definition_names,
    };

    writeln!(
        out,
        "// Code generated by jtd-codegen {}. DO NOT EDIT.",
        ast_.version
    )?;

    for (type_name, type_) in &id_state.id_table {
        writeln!(out)?;

        match type_ {
            ast::Type::TypeAlias(type_alias) => {
                render_typedoc(out, &type_alias.description)?;
                writeln!(
                    out,
                    "export type {} = {};",
                    type_name,
                    render_type_ref(&id_state, &type_alias.type_)
                )?;
            }

            ast::Type::Interface(interface) => {
                render_typedoc(out, &interface.description)?;
                writeln!(out, "export interface {} {{", type_name)?;
                for (field_name, field) in &interface.fields {
                    let blank_or_question = if field.optional { "?" } else { "" };
                    writeln!(
                        out,
                        "  {}{}: {};",
                        field_name,
                        blank_or_question,
                        render_type_ref(&id_state, &field.type_)
                    )?;
                }
                writeln!(out, "}}")?;
            }
        }
    }

    writeln!(out)?;

    Ok(())
}

fn render_typedoc(out: &mut dyn Write, comment: &str) -> Result<()> {
    write!(
        out,
        "{}",
        surrounded_comment_block(80, "/**", " * ", " */", comment)
    )?;

    Ok(())
}

fn render_type_ref(id_state: &IdState, type_ref: &ast::TypeRef) -> String {
    match type_ref {
        ast::TypeRef::Primitive(s) => s.clone(),
        ast::TypeRef::Identifier(id) => id_state.id_table[*id].0.clone(),
        ast::TypeRef::UndefinedOr(t) => format!("({} | undefined)", render_type_ref(id_state, t)),
        ast::TypeRef::ArrayOf(t) => format!("{}[]", render_type_ref(id_state, t)),
        ast::TypeRef::ObjectOf(t) => {
            format!("{{ [key: string]: {} }}", render_type_ref(id_state, t))
        }
        ast::TypeRef::Definition(d) => id_state.id_table[id_state.definition_names[d]].0.clone(),
        ast::TypeRef::UnionOf(ts) => format!(
            "({})",
            ts.iter()
                .map(|t| render_type_ref(id_state, t))
                .collect::<Vec<_>>()
                .join(" | ")
        ),
    }
}
